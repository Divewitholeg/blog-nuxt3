{"version":3,"file":"ContentRendererMarkdown-8b0fb622.js","sources":["../../../../node_modules/@nuxt/content/dist/runtime/components/ContentRendererMarkdown.vue"],"sourcesContent":["<script>\nimport { h, resolveComponent, Text, defineComponent, toRaw } from \"vue\";\nimport destr from \"destr\";\nimport { pascalCase } from \"scule\";\nimport { find, html } from \"property-information\";\nimport { useRuntimeConfig, useRoute } from \"#app\";\nimport htmlTags from \"../utils/html-tags\";\nconst DEFAULT_SLOT = \"default\";\nconst rxOn = /^@|^v-on:/;\nconst rxBind = /^:|^v-bind:/;\nconst rxModel = /^v-model/;\nconst nativeInputs = [\"select\", \"textarea\", \"input\"];\nexport default defineComponent({\n  name: \"ContentRendererMarkdown\",\n  props: {\n    /**\n     * Content to render\n     */\n    value: {\n      type: Object,\n      required: true\n    },\n    /**\n     * Render only the excerpt\n     */\n    excerpt: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Root tag to use for rendering\n     */\n    tag: {\n      type: String,\n      default: \"div\"\n    },\n    /**\n     * The map of custom components to use for rendering.\n     */\n    components: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  async setup(props) {\n    const { content: { tags = {} } } = useRuntimeConfig().public;\n    await resolveContentComponents(props.value.body, {\n      tags: {\n        ...tags,\n        ...toRaw(props.value?._components || {}),\n        ...props.components\n      }\n    });\n    return { tags };\n  },\n  render(ctx) {\n    const { tags, tag, value, components } = ctx;\n    if (!value) {\n      return null;\n    }\n    let body = value.body || value;\n    if (ctx.excerpt && value.excerpt) {\n      body = value.excerpt;\n    }\n    const meta = {\n      ...value,\n      tags: {\n        ...tags,\n        ...toRaw(value?._components || {}),\n        ...components\n      }\n    };\n    let component = meta.component || tag;\n    if (typeof meta.component === \"object\") {\n      component = meta.component.name;\n    }\n    component = resolveVueComponent(component);\n    return h(\n      component,\n      { ...meta.component?.props, ...this.$attrs },\n      renderSlots(body, h, meta, meta)\n    );\n  }\n});\nfunction renderNode(node, h2, documentMeta, parentScope = {}) {\n  if (node.type === \"text\") {\n    return h2(Text, node.value);\n  }\n  if (node.tag === \"script\") {\n    return h2(Text, renderToText(node));\n  }\n  const originalTag = node.tag;\n  const renderTag = typeof node.props?.__ignoreMap === \"undefined\" && documentMeta.tags[originalTag] || originalTag;\n  if (node.tag === \"binding\") {\n    return renderBinding(node, h2, documentMeta, parentScope);\n  }\n  const component = resolveVueComponent(renderTag);\n  if (typeof component === \"object\") {\n    component.tag = originalTag;\n  }\n  const props = propsToData(node, documentMeta);\n  return h2(\n    component,\n    props,\n    renderSlots(node, h2, documentMeta, { ...parentScope, ...props })\n  );\n}\nfunction renderToText(node) {\n  if (node.type === \"text\") {\n    return node.value;\n  }\n  if (!node.children?.length) {\n    return `<${node.tag}>`;\n  }\n  return `<${node.tag}>${node.children?.map(renderToText).join(\"\") || \"\"}</${node.tag}>`;\n}\nfunction renderBinding(node, h2, documentMeta, parentScope = {}) {\n  const data = {\n    ...parentScope,\n    $route: () => useRoute(),\n    $document: documentMeta,\n    $doc: documentMeta\n  };\n  const splitter = /\\.|\\[(\\d+)\\]/;\n  const keys = node.props?.value.trim().split(splitter).filter(Boolean);\n  const value = keys.reduce((data2, key) => {\n    if (key in data2) {\n      if (typeof data2[key] === \"function\") {\n        return data2[key]();\n      } else {\n        return data2[key];\n      }\n    }\n    return {};\n  }, data);\n  return h2(Text, value);\n}\nfunction renderSlots(node, h2, documentMeta, parentProps) {\n  const children = node.children || [];\n  const slotNodes = children.reduce((data, node2) => {\n    if (!isTemplate(node2)) {\n      data[DEFAULT_SLOT].push(node2);\n      return data;\n    }\n    const slotName = getSlotName(node2);\n    data[slotName] = data[slotName] || [];\n    data[slotName].push(...node2.children || []);\n    return data;\n  }, {\n    [DEFAULT_SLOT]: []\n  });\n  const slots = Object.entries(slotNodes).reduce((slots2, [name, children2]) => {\n    if (!children2.length) {\n      return slots2;\n    }\n    slots2[name] = () => {\n      const vNodes = children2.map((child) => renderNode(child, h2, documentMeta, parentProps));\n      return mergeTextNodes(vNodes);\n    };\n    return slots2;\n  }, {});\n  return slots;\n}\nfunction propsToData(node, documentMeta) {\n  const { tag = \"\", props = {} } = node;\n  return Object.keys(props).reduce(function(data, key) {\n    if (key === \"__ignoreMap\") {\n      return data;\n    }\n    const value = props[key];\n    if (rxModel.test(key) && !nativeInputs.includes(tag)) {\n      return propsToDataRxModel(key, value, data, documentMeta);\n    }\n    if (key === \"v-bind\") {\n      return propsToDataVBind(key, value, data, documentMeta);\n    }\n    if (rxOn.test(key)) {\n      return propsToDataRxOn(key, value, data, documentMeta);\n    }\n    if (rxBind.test(key)) {\n      return propsToDataRxBind(key, value, data, documentMeta);\n    }\n    const { attribute } = find(html, key);\n    if (Array.isArray(value) && value.every((v) => typeof v === \"string\")) {\n      data[attribute] = value.join(\" \");\n      return data;\n    }\n    data[attribute] = value;\n    return data;\n  }, {});\n}\nfunction propsToDataRxModel(key, value, data, documentMeta) {\n  const number = (d) => +d;\n  const trim = (d) => d.trim();\n  const noop = (d) => d;\n  const mods = key.replace(rxModel, \"\").split(\".\").filter((d) => d).reduce((d, k) => {\n    d[k] = true;\n    return d;\n  }, {});\n  const field = \"value\";\n  const event = mods.lazy ? \"change\" : \"input\";\n  const processor = mods.number ? number : mods.trim ? trim : noop;\n  data[field] = evalInContext(value, documentMeta);\n  data.on = data.on || {};\n  data.on[event] = (e) => documentMeta[value] = processor(e);\n  return data;\n}\nfunction propsToDataVBind(_key, value, data, documentMeta) {\n  const val = evalInContext(value, documentMeta);\n  data = Object.assign(data, val);\n  return data;\n}\nfunction propsToDataRxOn(key, value, data, documentMeta) {\n  key = key.replace(rxOn, \"\");\n  data.on = data.on || {};\n  data.on[key] = () => evalInContext(value, documentMeta);\n  return data;\n}\nfunction propsToDataRxBind(key, value, data, documentMeta) {\n  key = key.replace(rxBind, \"\");\n  data[key] = evalInContext(value, documentMeta);\n  return data;\n}\nconst resolveVueComponent = (component) => {\n  if (!htmlTags.includes(component) && !component?.render) {\n    const componentFn = resolveComponent(pascalCase(component), false);\n    if (typeof componentFn === \"object\") {\n      return componentFn;\n    }\n  }\n  return component;\n};\nfunction evalInContext(code, context) {\n  const result = code.split(\".\").reduce((o, k) => typeof o === \"object\" ? o[k] : void 0, context);\n  return typeof result === \"undefined\" ? destr(code) : result;\n}\nfunction getSlotName(node) {\n  let name = \"\";\n  for (const propName of Object.keys(node.props || {})) {\n    if (!propName.startsWith(\"#\") && !propName.startsWith(\"v-slot:\")) {\n      continue;\n    }\n    name = propName.split(/[:#]/, 2)[1];\n    break;\n  }\n  return name || DEFAULT_SLOT;\n}\nfunction isTemplate(node) {\n  return node.tag === \"template\";\n}\nfunction mergeTextNodes(nodes) {\n  const mergedNodes = [];\n  for (const node of nodes) {\n    const previousNode = mergedNodes[mergedNodes.length - 1];\n    if (node.type === Text && previousNode?.type === Text) {\n      previousNode.children = previousNode.children + node.children;\n    } else {\n      mergedNodes.push(node);\n    }\n  }\n  return mergedNodes;\n}\nasync function resolveContentComponents(body, meta) {\n  const components = Array.from(new Set(loadComponents(body, meta)));\n  await Promise.all(components.map(async (c) => {\n    if (c?.render) {\n      return;\n    }\n    const resolvedComponent = resolveComponent(c);\n    if (resolvedComponent?.__asyncLoader && !resolvedComponent.__asyncResolved) {\n      await resolvedComponent.__asyncLoader();\n    }\n  }));\n  function loadComponents(node, documentMeta) {\n    if (node.type === \"text\" || node.tag === \"binding\") {\n      return [];\n    }\n    const renderTag = typeof node.props?.__ignoreMap === \"undefined\" && documentMeta.tags[node.tag] || node.tag;\n    const components2 = [];\n    if (node.type !== \"root\" && !htmlTags.includes(renderTag)) {\n      components2.push(renderTag);\n    }\n    for (const child of node.children || []) {\n      components2.push(...loadComponents(child, documentMeta));\n    }\n    return components2;\n  }\n}\n</script>\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}